// 14) Напишите программу, находящую для заданной последовательности длины N неотрицательных целых чисел необходимо: 
// максимальную сумму двух её элементов, номера которых различаются не менее чем на 5. Программа должна быть эффективной по времени и памяти

#include <iostream>
#include <ctime> // Включаем для оценки скорости работы
using namespace std;

struct rowMas { int valSort; int curVal; };

void MyQuickSort_2(rowMas *vMas, int maxN) { // алгоритм быстрой сортировки одномерного массива структур по элементу curVal
	int cntL = 0, cntC = 0, cntR = 0; // число элементов массива слева, в центре, справа при делении базового массива
	int halfR = maxN / 2;
	int basis = vMas[halfR].curVal; // опорная точка
	rowMas *masL = new rowMas[maxN]; // резервируем массивы для заполнения слева, справа, центр
	rowMas *masC = new rowMas[maxN];
	rowMas *masR = new rowMas[maxN];
	if (maxN > 1) {
		for (int i = 0; i < maxN; i++) {
			if (vMas[i].curVal < basis) {
				cntL++; // число элементов слева
				masL[cntL - 1] = vMas[i];
			}
			else if (vMas[i].curVal > basis) {
				cntR++; // число элементов справа
				masR[cntR - 1] = vMas[i];
			}
			else {
				cntC++;	 // число элементов центр
				masC[cntC - 1] = vMas[i];
			}
		}
		MyQuickSort_2(masL, cntL); // рекурсивно вызываем сами себя для левой половинки массива
		MyQuickSort_2(masR, cntR); // рекурсивно вызываем сами себя для правой половинки массива
	}

	int iPos = -1;
	for (int i = 0; i < cntL; i++) { // заполняем исходный массив из левой половинки
		iPos++;
		vMas[iPos] = masL[i];
	}
	for (int i = 0; i < cntC; i++) { // заполняем исходный массив из центра
		iPos++;
		vMas[iPos] = masC[i];
	}
	for (int i = 0; i < cntR; i++) { // заполняем исходный массив из правой половинки
		iPos++;
		vMas[iPos] = masR[i];
	}
}

void MyQuickSort_1(rowMas *vMas, int maxN) { // алгоритм быстрой сортировки одномерного массива структур по элементу valSort
	int cntL = 0, cntC = 0, cntR = 0; // число элементов массива слева, в центре, справа при делении базового массива
	int halfR = maxN / 2;
	int basis = vMas[halfR].valSort; // опорная точка
	rowMas *masL = new rowMas[maxN]; // резервируем массивы для заполнения слева, справа, центр
	rowMas *masC = new rowMas[maxN];
	rowMas *masR = new rowMas[maxN];
	if (maxN > 1) {
		for (int i = 0; i < maxN; i++) {
			if (vMas[i].valSort < basis) {
				cntL++; // число элементов слева
				masL[cntL - 1] = vMas[i];
			}
			else if (vMas[i].valSort > basis) {
				cntR++; // число элементов справа
				masR[cntR - 1] = vMas[i];
			}
			else {
				cntC++;	 // число элементов центр
				masC[cntC - 1] = vMas[i];
			}
		}
		// сразу сортируем для элементов с одинаковым значением valSort по элементу curVal
		if (cntC > 0) {
			MyQuickSort_2(masC, cntC);
		}
		//
		MyQuickSort_1(masL, cntL); // рекурсивно вызываем сами себя для левой половинки массива
		MyQuickSort_1(masR, cntR); // рекурсивно вызываем сами себя для правой половинки массива
	}

	int iPos = -1;
	for (int i = 0; i < cntL; i++) { // заполняем исходный массив из левой половинки
		iPos++;
		vMas[iPos] = masL[i];
	}
	for (int i = 0; i < cntC; i++) { // заполняем исходный массив из центра
		iPos++;
		vMas[iPos] = masC[i];
	}
	for (int i = 0; i < cntR; i++) { // заполняем исходный массив из правой половинки
		iPos++;
		vMas[iPos] = masR[i];
	}
}

int main()
{
	/* 
	Для максимальной эффективности по скорости будем использовать сортировку. Чтоб сохранить после сортировки порядок элементов в последовательности,
	значения последовательности пишем в структуру содержащей: valSort - собственно значение, curVal - порядок в последовательности.
	Например на i5-650 сортировка 1 млн. элементов заняла 1,5 сек. 
	*/

	int N; //размер последовательности
	int i, j, maxVal, sumVar, startTime, endTime;

	setlocale(LC_ALL, "Rus"); // русифицируем вывод

	cout << "Введите размер последовательности (не менее 6): " << endl;
	cin >> N;

	if (N < 6) {
		cout << endl << "Неправильно задан размер последовательности! Обработка прервана..." << endl;
		return 0;
	}

	rowMas *masVal = new rowMas[N]; // резервируем массив для заполнения последовательности

	// для тестирования заполняем последовательность произвольными значениями
	for (i = 0; i < N; i++) {
		masVal[i].valSort = rand();
		masVal[i].curVal = i+1; // порядок в последовательности
	}

	startTime = time(NULL); // время начала выполнения

	// СОБСТВЕННО само решение задачи:
	
	MyQuickSort_1(masVal, N); // Сортируем исходные данные

	// Т.к. последовательность отсортирована по возрастанию, а нам нужны максимальные значения, которые в хвосте списка, то движемся в обратном порядке
	// Не обязательно максимальной суммой будет сумма с самым максимальным числом, все зависит от расположения чисел
	// Условием прерывания будем считать когд макс.сумма для следующего числа (в порядке убывания) окажется меньше или равна имеющейся макс.суммы. 
	
	// Начальное значение - макс.сумма для самого максимального
	i = N - 1;
	for (j = i - 1; j >= 0; j--) { // пробегаем по числам, которые лежат ранее текущего
		if (abs(masVal[i].curVal - masVal[j].curVal) >= 5) { // если разница номеров в последовательности >= 5
			maxVal = masVal[i].valSort + masVal[j].valSort;
			break;
		}
	}
	// Теперь по остальным 
	for (i = N - 2; i >= 0; i--) {
		for (j = i - 1; j >= 0; j--) { // пробегаем по числам, которые лежат ранее текущего
			if (abs(masVal[i].curVal - masVal[j].curVal) >= 5) { // если разница номеров в последовательности >= 5
				sumVar = masVal[i].valSort + masVal[j].valSort;
				break;
			}
		}
		if (sumVar <= maxVal) { // условие прерывания цикла
			break;
		}
		// новый максимум
		maxVal = sumVar;
	}
	// конец собственно решения

	endTime = time(NULL); // время конца выполнения

	// далее просто выводим исходные данные и результат. Это для тестирования работоспособности. Можно закомментировать до return 0
	cout << endl << "Выполнение заняло (с): " << endTime - startTime << endl;
	cout << endl << "Максимальная сумма: " << maxVal << endl;
	/*
	// для проверки сортировки массива - 30 первых и 30 последних
	cout << endl << "Исходные данные: " << endl;
	for (i = 0; i < 30; i++) {
		cout << masVal[i].valSort << " " << masVal[i].curVal << endl;
	}

	for (i = N - 30; i < N; i++) {
		cout << masVal[i].valSort << " " << masVal[i].curVal << endl;
	}
	*/

	return 0;
}
