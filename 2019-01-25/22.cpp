/* 22) Дан набор из N целых положительных чисел. Необходимо выбрать из набора произвольное количество чисел так, 
чтобы их сумма была как можно больше и при этом не делилась на 6. В ответе нужно указать количество выбранных чисел и их сумму,
сами числа выводить не надо. Если получить нужную сумму невозможно, считается, что выбрано 0 чисел и их сумма равна 0.
Напишите эффективную по времени и по памяти программу для решения этой задачи.
*/

#include <iostream>
#include <ctime> // Включаем для оценки скорости работы

using namespace std;

void MyQuickSort(int *vMas, int maxN) { // алгоритм быстрой сортировки
	int cntL = 0, cntC = 0, cntR = 0; // число элементов массива слева, в центре, справа при делении базового массива
	int halfR = maxN / 2;
	int basis = vMas[halfR]; // опорная точка
	int *masL = new int[maxN]; // резервируем массивы для заполнения слева, справа, центр
	int *masC = new int[maxN];
	int *masR = new int[maxN];
	if (maxN > 1) {
		for (int i = 0; i < maxN; i++) {
			if (vMas[i] < basis) {
				cntL++; // число элементов слева
				masL[cntL - 1] = vMas[i];
			}
			else if (vMas[i] > basis) {
				cntR++; // число элементов справа
				masR[cntR - 1] = vMas[i];
			}
			else {
				cntC++;	 // число элементов центр
			}
		}
		MyQuickSort(masL, cntL); // рекурсивно вызываем сами себя для левой половинки массива
		MyQuickSort(masR, cntR); // рекурсивно вызываем сами себя для правой половинки массива
	}

	int iPos = -1;
	for (int i = 0; i < cntL; i++) { // заполняем исходный массив из левой половинки
		iPos++;
		vMas[iPos] = masL[i];
	}
	for (int i = 0; i < cntC; i++) { // заполняем исходный массив из центра
		iPos++;
		vMas[iPos] = basis;
	}
	for (int i = 0; i < cntR; i++) { // заполняем исходный массив из правой половинки
		iPos++;
		vMas[iPos] = masR[i];
	}

}

int main()
{
	int N; //размер последовательности
	int i, maxSum, minVal, numCnt, startTime, endTime;
	bool find6;

	setlocale(LC_ALL, "Rus"); // русифицируем вывод

	cout << "Введите размер последовательности: ";	cin >> N;

	int *masVal = new int[N]; // резервируем массив для заполнения последовательности

	// для тестирования заполняем последовательность произвольными значениями
	for (i = 0; i < N; i++) {
		masVal[i] = rand();
	}

	startTime = time(NULL); // время начала выполнения

	// СОБСТВЕННО само решение задачи:
	maxSum = 0;
	numCnt = N;
	// сначала складываем все числа последовательности и проверим на делимость на 6
	for (i = 0; i < N; i++) { // пробегаемся по всем элементам
		maxSum = maxSum + masVal[i];
	}

	if (maxSum % 6 == 0) { // если сумма всех элементов нацело разделилась на 6
	// тогда сортируем элементы по возрастанию и пытаемся найти минимальное число, которое не делится на 6 и вычитаем из максимальной суммы
		MyQuickSort(masVal, N);
		find6 = false;
		minVal = 0;
		for (i = 0; i < N; i++) { // пробегаемся по всем элементам
			if (masVal[i] % 6 > 0) { // не делится нацело на 6
				find6 = true;
				minVal = masVal[i];
				break;
			}
		}
		if (find6) { // нашлось число не делящееся на 6
			maxSum = maxSum - minVal;
			numCnt--;
		}
		else {
			maxSum = 0;
			numCnt = 0;
		}
	}
	// конец собственно решения

	endTime = time(NULL); // время конца выполнения

	cout << endl << "Выполнение заняло (с): " << endTime - startTime << endl;
	cout << endl << "Количество чисел: " << numCnt << "  Сумма чисел: " << maxSum << endl;

	return 0;
}


